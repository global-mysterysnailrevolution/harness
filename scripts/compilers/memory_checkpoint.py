#!/usr/bin/env python3
"""
Memory Checkpoint Compiler
Generates WORKING_MEMORY.md and DECISIONS.md from raw memory log
"""

import os
import sys
import argparse
import re
from pathlib import Path
from datetime import datetime
from typing import List, Dict

def parse_memory_log(log_path: Path) -> Dict[str, any]:
    """Parse raw memory log into structured data"""
    checkpoints = []
    current_checkpoint = None
    
    with open(log_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if line.startswith('===') and 'Memory Checkpoint' in line:
                if current_checkpoint:
                    checkpoints.append(current_checkpoint)
                current_checkpoint = {
                    'timestamp': '',
                    'context': '',
                    'content': []
                }
                # Extract timestamp
                match = re.search(r'(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})', line)
                if match:
                    current_checkpoint['timestamp'] = match.group(1)
            elif current_checkpoint:
                if line.startswith('Context:'):
                    current_checkpoint['context'] = line
                elif line:
                    current_checkpoint['content'].append(line)
    
    if current_checkpoint:
        checkpoints.append(current_checkpoint)
    
    return {'checkpoints': checkpoints}

def extract_decisions(content: List[str]) -> List[str]:
    """Extract decision points from content"""
    decisions = []
    decision_keywords = ['decided', 'decision', 'chose', 'selected', 'TODO', 'FIXME', 'NOTE']
    
    for line in content:
        for keyword in decision_keywords:
            if keyword.lower() in line.lower():
                decisions.append(line)
                break
    
    return decisions

def generate_working_memory(data: Dict, output_path: Path):
    """Generate WORKING_MEMORY.md"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    content = f"""# Working Memory
Last Updated: {timestamp}

## Session State

### Current Status
- **Repository**: Active
- **Last Checkpoint**: {data['checkpoints'][-1]['timestamp'] if data['checkpoints'] else 'None'}
- **Context**: {data['checkpoints'][-1]['context'] if data['checkpoints'] else 'Unknown'}

## Memory Checkpoints

"""
    
    for i, checkpoint in enumerate(data['checkpoints'][-10:], 1):  # Last 10 checkpoints
        content += f"### Checkpoint {i}: {checkpoint['timestamp']}\n\n"
        content += f"**Context**: {checkpoint['context']}\n\n"
        if checkpoint['content']:
            content += "**Content**:\n"
            for line in checkpoint['content'][:20]:  # Limit per checkpoint
                content += f"- {line}\n"
            if len(checkpoint['content']) > 20:
                content += f"- ... ({len(checkpoint['content']) - 20} more lines)\n"
        content += "\n"
    
    content += f"""
## Notes
This file is automatically generated from raw memory logs.
See `ai/memory/raw_memory.log` for complete history.

## Last Updated
{timestamp}
"""
    
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    print(f"✓ Generated: {output_path}")

def generate_decisions(data: Dict, output_path: Path):
    """Generate DECISIONS.md"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    all_decisions = []
    for checkpoint in data['checkpoints']:
        decisions = extract_decisions(checkpoint['content'])
        for decision in decisions:
            all_decisions.append({
                'timestamp': checkpoint['timestamp'],
                'decision': decision
            })
    
    content = f"""# Decisions Log
Last Updated: {timestamp}

## Recorded Decisions

"""
    
    if all_decisions:
        for decision in all_decisions[-50:]:  # Last 50 decisions
            content += f"### {decision['timestamp']}\n\n"
            content += f"{decision['decision']}\n\n"
    else:
        content += "No decisions recorded yet.\n\n"
    
    content += f"""
## Notes
Decisions are automatically extracted from memory checkpoints.
Review `ai/memory/WORKING_MEMORY.md` for full context.

## Last Updated
{timestamp}
"""
    
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    print(f"✓ Generated: {output_path}")

def main():
    parser = argparse.ArgumentParser(description="Memory checkpoint compiler")
    parser.add_argument("--input", required=True, help="Input raw memory log")
    parser.add_argument("--output", default="ai/memory/WORKING_MEMORY.md", help="Output file path")
    parser.add_argument("--decisions", action="store_true", help="Generate decisions file")
    parser.add_argument("--repo", default=".", help="Repository root path")
    
    args = parser.parse_args()
    
    repo_path = Path(args.repo).resolve()
    input_path = Path(args.input).resolve()
    output_path = repo_path / args.output
    
    data = parse_memory_log(input_path)
    
    if args.decisions:
        decisions_path = repo_path / "ai/memory/DECISIONS.md"
        generate_decisions(data, decisions_path)
    else:
        generate_working_memory(data, output_path)

if __name__ == "__main__":
    main()
