"""
Provenance headers and SBOM generation for generated artifacts.

Every file generated by ContextForge gets a provenance header.
Every skill pack gets a CycloneDX-compatible SBOM.
"""
from __future__ import annotations

import json
import hashlib
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional

VERSION = "0.1.0"


def add_provenance_header(
    content: str,
    file_type: str,
    source_commit: str,
    analysis_hash: str,
    source_repo: str = "",
) -> str:
    """
    Prepend a provenance header to generated content.

    Args:
        content: The generated file content
        file_type: 'markdown', 'json', 'python', 'yaml'
        source_commit: Git commit hash of the analyzed repo
        analysis_hash: Hash of the analysis result
        source_repo: Repository path/URL

    Returns:
        Content with provenance header prepended
    """
    ts = datetime.now(timezone.utc).isoformat()

    if file_type == "markdown":
        header = (
            f"<!-- Generated by ContextForge v{VERSION} -->\n"
            f"<!-- Source: {source_repo} -->\n"
            f"<!-- Commit: {source_commit} -->\n"
            f"<!-- Analysis hash: {analysis_hash} -->\n"
            f"<!-- Generated at: {ts} -->\n"
            f"<!-- DO NOT EDIT: regenerate with `contextforge generate` -->\n\n"
        )
    elif file_type == "json":
        # JSON doesn't support comments; provenance goes in a _provenance key
        try:
            data = json.loads(content)
            data["_provenance"] = {
                "generator": "contextforge",
                "version": VERSION,
                "source_commit": source_commit,
                "analysis_hash": analysis_hash,
                "generated_at": ts,
            }
            return json.dumps(data, indent=2, ensure_ascii=False)
        except json.JSONDecodeError:
            return content
    elif file_type == "python":
        header = (
            f'# Generated by ContextForge v{VERSION}\n'
            f'# Source commit: {source_commit}\n'
            f'# Analysis hash: {analysis_hash}\n'
            f'# Generated at: {ts}\n'
            f'# DO NOT EDIT: regenerate with `contextforge generate`\n\n'
        )
    elif file_type == "yaml":
        header = (
            f'# Generated by ContextForge v{VERSION}\n'
            f'# Source commit: {source_commit}\n'
            f'# Analysis hash: {analysis_hash}\n'
            f'# Generated at: {ts}\n\n'
        )
    else:
        header = ""

    return header + content


def generate_sbom(
    skill_dir: Path,
    skill_id: str,
    version: str,
    dependencies: Optional[dict] = None,
) -> Path:
    """
    Generate a minimal CycloneDX-compatible SBOM for a skill pack.

    Args:
        skill_dir: Directory of the skill pack
        skill_id: Skill identifier
        version: Skill version
        dependencies: Optional dependency info from manifest

    Returns:
        Path to the generated SBOM file
    """
    components = []

    # The skill itself
    components.append({
        "type": "application",
        "name": f"contextforge-skill-{skill_id}",
        "version": version,
        "purl": f"pkg:contextforge/skill/{skill_id}@{version}",
    })

    # Dependencies
    if dependencies:
        for pkg in dependencies.get("packages", []):
            purl_type = {
                "npm": "npm", "pip": "pypi", "apt": "deb", "brew": "brew",
            }.get(pkg.get("manager", ""), "generic")
            components.append({
                "type": "library",
                "name": pkg["name"],
                "version": pkg.get("version", "latest"),
                "purl": f"pkg:{purl_type}/{pkg['name']}@{pkg.get('version', 'latest')}",
            })

    sbom = {
        "bomFormat": "CycloneDX",
        "specVersion": "1.5",
        "version": 1,
        "metadata": {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "tools": [{
                "vendor": "contextforge",
                "name": "contextforge-sbom",
                "version": VERSION,
            }],
            "component": {
                "type": "application",
                "name": f"contextforge-skill-{skill_id}",
                "version": version,
            },
        },
        "components": components,
    }

    sbom_path = skill_dir / "sbom.json"
    with open(sbom_path, "w", encoding="utf-8") as f:
        json.dump(sbom, f, indent=2, ensure_ascii=False)

    return sbom_path
